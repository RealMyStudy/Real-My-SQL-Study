
# 5. 트랜잭션과 잠금

## 5.1 트랜잭션

트랜잭션은 작업의 완전성을 보장해 주는 것이다. 

- 모두 적용되거나 모두 적용되지 않거나 (All or Nothing)
- MySQL 의 InnoDB 는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다.

MyISAM, Memory 엔진은 전체를 원 상태로 만들지 않고 부분 업데이트를 하게 된다

- 부분 업데이트 현상은 데이터의 정합성을 맞추는데 어려움을 준다.

프로그램 코드에서 트랜잭션의 범위를 최소화해야 한다

- 데이터베이스 커넥션은 개수가 제한적이라서 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어들 것이다.
- 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 있다.
- 네트워크 작업은 트랜잭션 범위에서 제외해야 한다.
    - 네트워크 작업 시간은 길기 때문에 커넥션 점유 시간이 길어질 수 있다.
    - DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠지는 경우가 발생할 수 있다.
    - 네트워크 작업에 대한 롤백은 어떻게?
        - 보상트랜잭션 api 를 호출해서 해결하는 방법도 있다고 합니다.

## 5.2 MySQL 엔진의 잠금

### 5.2.1 글로벌락

- MySQL 에서 제공하는 잠금 가운데 가장 범위가 크다.
- 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.

### 5.2.2 테이블 락

- 개별 테이블 단위로 설정되는 잠금
- 특별한 상황이 아니면 애플리케이션에서 사용할 필요가 거의 없다.
- MyISAM , Memory 엔진을 사용하는 테이블의 데이터를 변경하는 쿼리를 실행하면 발생한다.

### 5.2.3 네임드 락

- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정하는 락.
- 데이터베이스 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건처럼 여러 클라이언트가 상호 동기화를 처리해야 할 때 사용
- 많은 레코드에 대해 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용 가능

참고 : [https://javacan.tistory.com/entry/simple-distributed-lock-using-db](https://javacan.tistory.com/entry/simple-distributed-lock-using-db)

### 5.2.4 메타데이터 락

- 데이터베이스 객체(테이블,뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 락이다.
- 명시적으로 획득,해제 하는 것이 아닌 자동으로 획득하는 락
- 실시간으로 테이블을 바꿔야 하는 경우에 사용 가능
- Online DDL
    - 리마큐 2권에 나와요.

## 5.3 Innodb 스토리지 엔진 잠금

InnoDB 스토리지 엔진은 레코드 기반의 잠금을 탑재하고 있다.

### 5.3.1.1 레코드 락

- 레코드 자체를 잠그는 락이다.
- InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
- 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.

### 5.3.1.2 갭 락

레코드와 바로 인접한 레코드 사이의 간격을 잠그는 락이다.

### 5.3.1.3 넥스트 키 락

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락 이라고 한다.

### 5.3.1.4 자동 증가 락

- AUTO_INCREMENT 컬럼이 사용된 테이블에 여러 레코드를 INSERT 하는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 한다. InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준 잠금을 사용한다.
- UPDATE, DELETE 등의 쿼리에서는 사용 안한다.
- AUTO_INCREMENT 락은 테이블에 단 하나만 존재하기 때문에 두개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리에 락을 걸고 나머지 하나는 대기한다.
(AUTO_INCREMENT 컬럼에 명시적으로 값을 설정하더라도 자동증가 락을 걸게 된다)

### 5.3.2 인덱스와 잠금

- InnoDB 의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠근다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.
- 테이블에 인덱스가 하나도 없다면 어떻게 될까? 이러한 경우에는 테이블을 풀 스캔하면서 업데이트 작업을 하는데, 모든 레코드를 잠그게 된다.
    - MYSQL 에서 자체적으로  만든 키가 인덱스와 완전하게 동일한 역할
- 테이블에 pk 를 지정하지 않거나 적절한 유니크 인덱스가 없다면, InnoDB 는 클러스터 인덱스를 생성한다. 생성된 클러스터 인덱스에 의해 각 로우들이 정렬되어 진다.

참고 : [https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html](https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html)

## 5.4 MySQL의 격리 수준

트랜잭션 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

### 5.4.1 Read Uncommitted

- 각 트랜잭션에서의 변경 내용이 commit 이나 rollback 여부에 상관없이 다른 트랜잭션에서 보인다.
- Dirty Read 현상으로 인해 정합성에 문제가 많은 격리 수준이다.
    - Dirty Read : 데이터가 나타났다가 사라졌다 하는 현상

### 5.4.2 Read Committed

- 어떤 트랜잭션에서 데이터를 변경했더라도 commit 이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
- 어떤 트랜잭션에서 데이터를 변경하고 commit 하기 전에 다른 트랜잭션에서 그 데이터를 조회하면 변경하기 전 데이터를 조회할 수 있다. 언두영역의 데이터를 반환하기때문에 변경하기 전 데이터를 조회할 수 있는 것이다.
- Non Repeatable Read 현상이 발생해 정합성에 문제가 발생할 수 있다.
    - Non Repeatable Read : 한 트랜잭션 내에서 동일한 SELECT 쿼리의 결과가 동일하지 않은 현상을 말한다. 한 트랜잭션내에서 같은 SELECT 쿼리를 실행했을 때 같은 결과를 반환해야 한다는 원칙을 위반하는 현상.

### 5.4.3 Repeatable Read

- InnoDB 스토리지 엔진에서 기본으로 사용되는 격리수준이다.
- Non Repeatable Read 현상을 해결한 격리수준이다.
- Repeatable Read 는 MVCC 를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.
- Read Committed 도 MVCC 를 이용해 commit 되기 전의 데이터를 보여준다. Read Committed 와 Repeatable Read 의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다.
- 모든 InnoDB 트랜잭션은 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 레코드는 변경을 발생시킨 트랜잭션 번호가 포함돼 있다.

????맞나???

Repeatable Read 에서는 현재 트랜잭션 번호보다 이전에 발생한 트랜잭션의 언두로그 중 가장 최근 데이터가 반환되고 Read Committed 에서는 모든 트랜잭션의 언두로그 중 가장 최근 데이터가 반환된다.

- Repeatable Read 에서는 Phantom Read 라는 문제가 발생한다고 하지만 InnoDB 에서는 발생하지 않는다. 넥스트 키 락 덕분에 발생하지 않는다.
    - Phantom Read : 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상

### 5.4.4 Serializable

- 가장 엄격한 격리수준이지만 동시 처리 성능이 떨어진다.
- InnoDB 테이블은 잠금이 필요 없는 일관된 읽기를 제공하지만 Serializable 수준을 설정하면 잠금을 획득하게 된다. 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 접근할 수 없게 되는 것이다.
