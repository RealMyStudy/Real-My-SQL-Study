## 5장 - 트랜잭션과 잠금

---

__트랜잭션__ 이란 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우 원 상태로 복구해서 작업의 
일부만 적용되는 현상(Partial update) 이 발생하지 않게 만들어주는 기능이다.

잠금과 트랜잭션은 서로 비슷한 개념 같지만 둘은 다르다.
- 잠금은 동시성을 제어하기 위한 기능
- 트랜잭션은 데이터의 정합성을 보장하기 위한 기능

__격리 수준__이란 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레빌이다.

---

### 트랜잭션

#### MySQL 에서의 트랜잭션

트랜잭션은 여러 개의 변경 작업을 수행하는 쿼리가 조합됐을 때만 의미 있는 개념이 아닌 

하나의 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않음을 보장해 주는 것이다.

트랜잭션은 애플리케이션 개발에서 고민해야 할 문제를 줄여주는 __아주 필수적인 DBMS 기능이다.__

#### 주의 사항

트랜잭션은 __꼭 필요한 최소의 코드__ 에만 적용하는 것이 좋다.

구현하고자 하는 업무의 특성에 따라 다르겠지만 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와

트랜잭션이 활성화돼 있는 프로그램의 범위를 __최소화__ 해야 한다.

__네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다.__

#### MySQL 엔진의 잠금

MySQL에서 사용되는 잠금은 다음 두개로 나눌 수 있다.

- 스토리지 엔진 레벨
  - 스토리지 엔진 레벨의 잠금은 스토리지 엔진 강 상호 영향을 __미치지 않는다.__
- MySQL 엔진 레벨
  - 스토리지 엔진을 제외한 나머지 부분
  - MySQL 엔진 레벨은 모든 스토리지 엔진에 영향을 미친다.
    
#### 글로벌 락

글로벌 락은 MySQL에서 제공하는 잠금 가운데 __가장 범위가 크다.__

한 세션에서 글로벌 락을 획득하면 다른 세션에서 ```SELECT``` 를 제외한 대부분의 DDL 문장이나 DML 문장을 
실행하는 경우 글로벌 락이 __해제__ 될 때까지해당 문장이 __대기 상태__ 로 남는다.

__글로벌 락__ 은 __작업 대상 테이블이나 데이터베이스가 다르더라도 동일__ 하게 영향을 미친다.


#### 백업 락

``innoDB`` 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 변경 작업을 멈출 필요는 없다.

__MySQL 8.0__ 부터는 ``innoDB`` 스토리지 엔진이 기본으로 채택되면서 좀 더 가벼운 글로벌 락의 필요성이 생겨

``Xtrabackup`` 이나 ``Enterprise Backup`` 과 같은 백업 툴들의 안정적인 실행을 위해 __백업 락__ 이 도입됐다.

__백업 락__ 은 일반적인 테이블의 데이터 변경은 __허용된다.__

백업 락은 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 __DDL 명령이 실행되면 복제를 일시 중지__ 하는 역할을 한다.

#### 테이블 락

테이블 락은 개별 테이블 단위로 설정되는 잠금이다.

명시적, 묵시적으로 특정 테이블의 락을 획득할 수 있다.

명시적인 테이블 락은 특별한 상황이 아니면 애플리케이션에서 사용할 필요가 거의 없다.

명시적으로 테이블을 잠그는 작업은 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 떄문이다.

묵시적인 테이블 락은 ``MyISAM`` 이난 ``MEMORY`` 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.

```MySQL 서버가 데이터가 변경되는 테이블에 잠금 -> 데이터 변경 -> 즉시 잠금 해제```

의 형태로 사용된다.

``innoDB`` 스토리지 엔진의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 

__단순 데이터 변경으로 테이블 락이 설정되지는 않는다.__

정확히는 ``innoDB`` 테이블에도 테이블 락이 설정되지만 __DML 쿼리에서는 무시__ 되고

스키마를 변경하는 __DDL 쿼리__ 의 경우에만 영향을 미친다.

#### 네임드 락

네임드 락은 ``GET_LOCK()`` 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.

네임드 락의 특징은 __대상이 테이블이나 레코드__ 혹은 ``AUTO_INCREMENT`` 와 같은 데이터베이스 객체가 아니라는 것이다.

데이터 베이스 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에 5대의 웹 서버가 어떤 정보를 동기화해야하는 경우

즉, 여러 클라이언트가 상호 동기화를 처리해야할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.

__MySQL 8.0__ 부터는 네임드 락을 __중첩해서 사용__ 할 수 있게 됐으며

현재 세션에서 획득한 네임드 락을 한 번에 모두 해제하는 기능이 추가됐다.

#### 메타데이터 락

메타데이터 락은 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.

메타데이터 락은 __명시적으로 획득하거나 해제할 수 있는 것이 아니다.__

``RENAME TABLE tab_a TO tab_b`` 와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.

#### innoDB 의 트랜잭션과 메타데이터 잠금을 동시에 사용하는 경우가 나오는데 여기에 멀티 스레드 얘기가 나옴
#### MySQL 서버의 DDL 은 단일 스레드로 동작하는데 멀티 스레드로 하는 방법이 있는 건지 이해가 잘 안됨. 논의하면 좋을 듯

---

#### InnoDB 스토리지 엔진 잠금

__InnoDB 스토리지 엔진__ 에서의 잠금은 MySQL 에서 제공하는 잠금과 별개로

스토리지 엔진 내부에서 __레코드 기반__ 의 잠금 방식을 탑재하고 있다.

__InnoDB 스토리지 엔진__ 은 _레코드 기반__ 의 잠금 방식을 통해 __MyISAM__ 엔진 보다 훨씬 뛰어난 동시성 처리를 제공한다.

예전에는 MySQL 명령을 통해 스토리지 엔진에서 사용되는 잠금에 대한 정보에 접근하기가 까다로웠지만

최근 버전에서는 __InnoDB 스토리지 엔진__ 의 트랜잭션, 잠금, 잠금 대기 중인 트랜잭션의 목록을 조회하는 방법이 도입됐다.

#### InnoDB 스토리지 엔진의 잠금

__InnoDB 스토리지 엔진__ 은 __레코드 기반__ 의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에

``레코드 락 -> 페이지 락 or 테이블 락`` 으로 레벨업되는 경우는 없다.

일반 __DBMS__ 와는 다르게 __InnoDB 스토리지 엔진__ 에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 __갭 락__ 이 존재한다.






