## 5장 - 트랜잭션과 잠금

---

__트랜잭션__ 이란 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우 원 상태로 복구해서 작업의 
일부만 적용되는 현상(Partial update) 이 발생하지 않게 만들어주는 기능이다.

잠금과 트랜잭션은 서로 비슷한 개념 같지만 둘은 다르다.
- 잠금은 동시성을 제어하기 위한 기능
- 트랜잭션은 데이터의 정합성을 보장하기 위한 기능

__격리 수준__이란 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레빌이다.

---

### 트랜잭션

#### MySQL 에서의 트랜잭션

트랜잭션은 여러 개의 변경 작업을 수행하는 쿼리가 조합됐을 때만 의미 있는 개념이 아닌 

하나의 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않음을 보장해 주는 것이다.

트랜잭션은 애플리케이션 개발에서 고민해야 할 문제를 줄여주는 __아주 필수적인 DBMS 기능이다.__

#### 주의 사항

트랜잭션은 __꼭 필요한 최소의 코드__ 에만 적용하는 것이 좋다.

구현하고자 하는 업무의 특성에 따라 다르겠지만 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와

트랜잭션이 활성화돼 있는 프로그램의 범위를 __최소화__ 해야 한다.

__네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다.__

#### MySQL 엔진의 잠금

MySQL에서 사용되는 잠금은 다음 두개로 나눌 수 있다.

- 스토리지 엔진 레벨
  - 스토리지 엔진 레벨의 잠금은 스토리지 엔진 강 상호 영향을 __미치지 않는다.__
- MySQL 엔진 레벨
  - 스토리지 엔진을 제외한 나머지 부분
  - MySQL 엔진 레벨은 모든 스토리지 엔진에 영향을 미친다.
    
#### 글로벌 락

글로벌 락은 MySQL에서 제공하는 잠금 가운데 __가장 범위가 크다.__

한 세션에서 글로벌 락을 획득하면 다른 세션에서 ```SELECT``` 를 제외한 대부분의 DDL 문장이나 DML 문장을 
실행하는 경우 글로벌 락이 __해제__ 될 때까지해당 문장이 __대기 상태__ 로 남는다.

__글로벌 락__ 은 __작업 대상 테이블이나 데이터베이스가 다르더라도 동일__ 하게 영향을 미친다.


#### 백업 락

``innoDB`` 스토리지 엔진은 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 변경 작업을 멈출 필요는 없다.

__MySQL 8.0__ 부터는 ``innoDB`` 스토리지 엔진이 기본으로 채택되면서 좀 더 가벼운 글로벌 락의 필요성이 생겨

``Xtrabackup`` 이나 ``Enterprise Backup`` 과 같은 백업 툴들의 안정적인 실행을 위해 __백업 락__ 이 도입됐다.

__백업 락__ 은 일반적인 테이블의 데이터 변경은 __허용된다.__

백업 락은 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 __DDL 명령이 실행되면 복제를 일시 중지__ 하는 역할을 한다.

#### 테이블 락

테이블 락은 개별 테이블 단위로 설정되는 잠금이다.

명시적, 묵시적으로 특정 테이블의 락을 획득할 수 있다.

명시적인 테이블 락은 특별한 상황이 아니면 애플리케이션에서 사용할 필요가 거의 없다.

명시적으로 테이블을 잠그는 작업은 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 떄문이다.

묵시적인 테이블 락은 ``MyISAM`` 이난 ``MEMORY`` 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.

```MySQL 서버가 데이터가 변경되는 테이블에 잠금 -> 데이터 변경 -> 즉시 잠금 해제```

의 형태로 사용된다.

``innoDB`` 스토리지 엔진의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 

__단순 데이터 변경으로 테이블 락이 설정되지는 않는다.__

정확히는 ``innoDB`` 테이블에도 테이블 락이 설정되지만 __DML 쿼리에서는 무시__ 되고

스키마를 변경하는 __DDL 쿼리__ 의 경우에만 영향을 미친다.

#### 네임드 락

네임드 락은 ``GET_LOCK()`` 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.

네임드 락의 특징은 __대상이 테이블이나 레코드__ 혹은 ``AUTO_INCREMENT`` 와 같은 데이터베이스 객체가 아니라는 것이다.

데이터 베이스 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에 5대의 웹 서버가 어떤 정보를 동기화해야하는 경우

즉, 여러 클라이언트가 상호 동기화를 처리해야할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.

__MySQL 8.0__ 부터는 네임드 락을 __중첩해서 사용__ 할 수 있게 됐으며

현재 세션에서 획득한 네임드 락을 한 번에 모두 해제하는 기능이 추가됐다.

#### 메타데이터 락

메타데이터 락은 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.

메타데이터 락은 __명시적으로 획득하거나 해제할 수 있는 것이 아니다.__

``RENAME TABLE tab_a TO tab_b`` 와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.

#### innoDB 의 트랜잭션과 메타데이터 잠금을 동시에 사용하는 경우가 나오는데 여기에 멀티 스레드 얘기가 나옴
#### MySQL 서버의 DDL 은 단일 스레드로 동작하는데 멀티 스레드로 하는 방법이 있는 건지 이해가 잘 안됨. 논의하면 좋을 듯

---

#### InnoDB 스토리지 엔진 잠금

__InnoDB 스토리지 엔진__ 에서의 잠금은 MySQL 에서 제공하는 잠금과 별개로

스토리지 엔진 내부에서 __레코드 기반__ 의 잠금 방식을 탑재하고 있다.

__InnoDB 스토리지 엔진__ 은 _레코드 기반__ 의 잠금 방식을 통해 __MyISAM__ 엔진 보다 훨씬 뛰어난 동시성 처리를 제공한다.

예전에는 MySQL 명령을 통해 스토리지 엔진에서 사용되는 잠금에 대한 정보에 접근하기가 까다로웠지만

최근 버전에서는 __InnoDB 스토리지 엔진__ 의 트랜잭션, 잠금, 잠금 대기 중인 트랜잭션의 목록을 조회하는 방법이 도입됐다.

#### InnoDB 스토리지 엔진의 잠금

__InnoDB 스토리지 엔진__ 은 __레코드 기반__ 의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에

``레코드 락 -> 페이지 락 or 테이블 락`` 으로 레벨업되는 경우는 없다.

일반 __DBMS__ 와는 다르게 __InnoDB 스토리지 엔진__ 에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 __갭 락__ 이 존재한다.

#### 레코드 락

레코드 락은 레코드 자체만을 잠그는 락이다. 

InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이 다른 사용 DBMS 와의 차이점이다.

인덱스가 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.

__레코드 자체를 잠그느냐 인덱스를 잠그느냐는 중요한 차이점이 있다.__

대부분 보조 인덱스를 이용한 변경 작업은 넥스트 키락 또는 갭 락을 사용하지만

__프라이머리 키__ 나 __유니크 인덱스__ 에 의한 변경 작업에서는 갭에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.

#### 갭 락

갭 락은 레코드 자체가 아니라 __레코드와 바로 인접한 레코드 사이의 간격__ 만을 잠그는 것을 말한다.

갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 __제어하는 것이다.__

갭 락은 주로 넥스트 키 락의 일부로 자주 사용된다.

#### 넥스트 키 락

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다.

InnoDB 의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 

소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.

__넥스트 키 락__ 과 __갭 락__ 으로 인해 __데드락__ 이 발생하거나 다른 트랜잭션을 기다리게 하는 경우가 자주 발생하기 때문에

되도록이면 __바이너리 로그 포맷__ 을 __ROW__ 형태로 바꿔 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.

__MySQL 8.0__ 에서는 __바이너리 로그 포맷__ 설정이 __ROW__ 가 기본 설정으로 변경되었다.

#### 자동 증가 락

MySQL 에서는 자동 증가하는 숫자 값을 추출하기 위해 ``AUTO_INCREMENT`` 라는 컬럼 속성을 제공한다.

``AUTO_INCREMENT`` 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우 

저장되는 각 레코드는 중복되지 않고 저장된 순서되로 증가하는 일련번호를 가져야한다.

InnoDB 에서는 이를 위해 내부적으로 ``AUTO_INCREMENT`` 락 이라고 하는 테이블 수준의 잠금을 제공한다.

AUTO_INCREMENT 락은 새로운 레코드를 저장하는 쿼리에서만 필요하며, ``UPDATE`` 나 ``DELETE`` 등의 쿼리에서는 걸리지 않는다.

AUTO_INCREMENT 락은 __트랜잭션과 관계없이__ ``INSERT`` 나 ``REPLACE`` 문장에서  

``AUTO_INCREMENT`` 값을 __가져오는 순간__ 에만 락이 걸렸다가 __즉시__ 해제된다.

만약 두개의 ``INSERT`` 쿼리가 동시에 실행되는 경우 하나의 쿼리가 AUTO_INCREMENT 락을 걸면 

나머지 쿼리는 AUTO_INCREMENT 락을 기다려야 한다.

AUTO_INCREMENT 락을 명시적으로 획득하고 해제하는 방법은 __없다.__

__MySQL 5.1__ 이상부터는 ``innodb_autinc_lock_meta`` 라는 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있다.

만약 ``INSERT`` 쿼리가 실패했더라도 한 번 증가된 ``AUTO_INCREMENT`` 값은 다시 줄어들지 않는다.

#### 인덱스와 잠금

InnoDB 의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.

변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야한다.

만약 테이블에 인덱스가 하나도 없다면 테이블을 풀 스캔하면서 ``UPDATE`` 작업을 하는데 테이블에 있는 모든 레코드를 잠그게 된다.

때문에 MySQL의 InnoDB에서 인덱스의 설계가 중요하다.

#### 레코드 수준의 잠금 확인 및 해제

레코드 수준의 잠금은 테이블의 레코드 각각에 잠금이 걸리므로 그 레코드가 자주 사용되지 않는다면 오랜 시간동안 잠겨진 상태로 남아 있어도 잘 발견되지 않는다.

__MySQL 5.1__ 부터는 레코드 잠금과 잠금 대기에 대한 조회가 가능해졌다.

---

### MySQL 의 격리 수준

트랜잭션의 격리 수준(isolation level)이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션에 다른 트랜잭션에서 변경하거나

조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

격리 수준은 크게 4가지가 있다.
- READ UNCOMMITTED (일반적인 데이터베이스에서는 거의 사용하지 않음)
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

``READ UNCOMMITTED -> READ COMMITTED -> REPEATABLE READ -> SERIALIZABLE`` 의 순서로

뒤로 갈수록 각 트랜잭션 간의 데이터 격리 정도가 높아지며, 동시 처리 성능도 떨어지는 것이 일반적이다.

``SERIALIZABLE`` 격리 수준이 아니라면 크게 성능의 개션이나 저하는 발생하지 않는다.

격리 수준에 따라 ``DIRTY READ`` , ``NON-REPEATABLE READ``, ``PHANTOM READ`` 의 부정합 문제가 발생할 수 있다.

``REPEATABLE READ`` 격리 수준에서는 ``PHANTOM READ`` 가 발생할 수 있지만 InnoDB의 특성 때문에

``REPEATABLE READ`` 격리 수준에서도 ``PHANTOM READ`` 는 발생하지 않는다.

일반적인 데이터베이스는 ``READ COMMITTED`` 와 ``REPEATABLE READ`` 중 하나를 사용한다.

__MySQL에서는 REPEATABLE READ 수준을 많이 사용한다.__

#### READ UNCOMMITTED

READ UNCOMMITTED 격리 수준에서는 __각 트랜잭션의 변경 내용이 COMMIT 이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다.__

문제는 다른 트랜잭션에서 쿼리를 처리하는 도중 문제가 발생해 INSERT 된 내용을 롤백한다고 해도 

여전히 다른 트랜잭션에서는 INSERT 된 레코드를 정상적인 레코드라고 생각하고 계속 처리하게 된다.

이렇게 __어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상__ 을 __DIRTY READ__ 라고 한다.

__DIRTY READ__ 가 허용되는 격리 수준이 __READ UNCOMMITTED__ 이다.

더티 리드는 애플리케이션 개발자와 사용자를 상당히 혼란스럽게 만들기 때문에 더티 리드를 유발하는 __READ UNCOMMITTED__ 격리 수준을

__RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않는다.__

#### READ COMMITTED

__READ COMMITTED__ 격리 수준은 __오라클 DBMS__ 에서 기본으로 사용되는 격리 수준이다.

온라인 서비스에서 가장 많이 선택되는 격리 수준이기도 하다.

__READ COMMITTED__ 격리 수준에서는 __DIRTY READ__ 가 __발생하지 않는다.__

__어떤 트랜잭션에서 데이터를 변경__ 했더라도 __COMMIT__ 이 완료된 데이터만 다른 트랜잭션에서 __조회할 수 있다.__

__READ COMMITTED__ 격리 수준에서는 __NON-REPEATABLE READ__ 부정합이 발생하는 문제가 있다.

어떤 트랜잭션에서 변경된 내용이 __COMMIT__ 후에 다른 트랜잭션에서 보이기 때문에 

하나의 트랜잭션 내에서 똑같은 ``SELECT`` 쿼리를 실행했을 때 항상 같은 결과를 가져와야한다는 __REPEATABLE READ__ 정합성에 어긋날 수 있다.

입금과 출금 처리가 계속 진행될 때 __REPEATABLE READ__ 가 보장되지 않음으로 ``SELECT`` 쿼리를 실행할 때마다 다른 결과를 가져올 것이다.

__READ COMMITTED__ 격리 수준에서는 __트랜잭션 내에서 실행하는 SELECT__ 와 __트랜잭션 외부에서 실행하는 SELECT__ 문장의 차이가 별로 없다.

#### REPEATABLE READ

REPEATABLE READ 격리 수준은 __MySQL__ 의 __InnoDB__ 스토리지 엔진에서 기본으로 사용되는 격리 수준이다.

바이너리 로그를 가진 __MySQL__ 서버에서는 최소 __REPEATABLE READ__ 격리 수준 이상을 사용해야 한다.

__REPEATABLE READ__ 격리 수준에서는 __NON-REPEATABLE READ__ 부정합이 발생하지 않는다.

__InnoDB__ 스토리지 엔진은 트랜잭션이 ROLLBACK 될 가능성에 대비해 벼경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경한다.

이런 방식을 __MVCC__ 라고 하며 __REPEATABLE READ__ 는 이 __MVCC__ 를 위해 

__언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.__

__READ COMMITTED__ 격리 수준도 __MVCC__ 를 이용해 __COMMIT__ 전의 데이터를 보여주는데

__REPEATABLE READ__ 와 __READ COMMITTED__ 격리 수준의 차이점은 __언두 영역에 백업된 레코드의 여러개 버전 중 몇번 째 이전 버전까지 찾아 들어가느냐__ 의 차이다.

모든 __InnoDB__ 의 트랜잭션은 __고유한 트랜잭션 번호__ 를 갖는데 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 __포함돼 있다.__

__REPEATABLE READ__ 격리 수준에서는 __MVCC__ 를 보장하기 위해 실행 중인 트랜잭션 가운데 __가장 오래된 트랜잭션 번호__ 보다 __트랜잭션 번호가 앞선 언두 영역의 데이터__ 는 삭제할 수 없다.

__REPEATABLE READ__ 격리 수준에서는 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 __보였다 안 보였다__ 하는 현상이 발생한다.

이를 __PHANTOM READ__ 라고 한다.

__InnoDB__ 에서는 MVCC와 레코드 레벨 잠금 등의 기능을 통해 PHANTOM READ 가 발생하지 않도록 보호한다.

#### SERIALIZABLE

__SERIALIZABLE__ 격리 수준은 가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준이다.

때문에 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다.

__SERIALIZABLE__ 격리 수준으로 설정되면 __읽기 작업에서도 공유 잠금을 획득해야하며__ 동시에 다른 트랜잭션은 그 레코드를 변경하지 못하게 된다.

즉, __한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.__

__SERIALIZABLE__ 격리 수준에서는 __PHANTOM READ__ 가 발생하지 않는다.

__InnoDB__ 스토리지 엔진에서는 __갭 락__ 과 __넥스트 키 락__ 덕분에 

__REPEATABLE READ__ 격리 수준에서도 __PHANTOM READ__ 가 발생하지 않기 떄문에 굳이 __SERIALIZABLE__ 격리 수준을 사용할 필요성은 없다.

